//
//  Dictionary.swift
//  ExSwift
//
//  Created by pNre on 04/06/14.
//  Copyright (c) 2014 pNre. All rights reserved.
//

import Foundation
import Swift

extension Dictionary {
    
    /**
    *  Computes the difference between self and the input dictionaries
    *  @param dictionaries Dictionaries to subtract
    *  @return Difference between self and the input dictionaries
    */
    func difference <V: Equatable> (dictionaries: Dictionary<KeyType, V>...) -> Dictionary<KeyType, V> {

        //  Cast everything to V
        var result = Dictionary<KeyType, V>()
        
        each {
            if let item = $1 as? V {
                result[$0] = item
            }
        }
        
        //  Difference
        for dictionary in dictionaries {
            for (key, value) in dictionary {
                if result.has(key) && result[key] == value {
                    result.removeValueForKey(key)
                }
            }
        }
        
        return result
        
    }
    
    /**
    *  Computes the union between self and the input dictionaries
    *  @param dictionaries Dictionaries to join
    *  @return Union between self and the input dictionaries
    */
    func union (dictionaries: Dictionary<KeyType, ValueType>...) -> Dictionary<KeyType, ValueType> {

        var result = self
        
        //  Union
        dictionaries.each { (dictionary) -> Void in
            dictionary.each { (key, value) -> Void in
                result.updateValue(value, forKey: key)
                return
            }
        }

        return result
        
    }
    
    /**
    *  Computes the intersection between self and the input dictionaries
    *  @param values Dictionaries to intersect
    *  @return Dictionary of (key, value) couples present in all the dictionaries + self
    */
    func intersection <K, V where K: Equatable, V: Equatable> (dictionaries: Dictionary<K, V>...) -> Dictionary<K, V> {
        
        //  Converts self from <KeyType, ValueType> to <K, V>
        let filtered = self.filter({
            (item: KeyType, value: ValueType) -> Bool in
            return (item is K) && (value is V)
        }).map({
            (item: KeyType, value: ValueType) -> (K, V) in
            return (item as K, value as V)
        })

        //  Intersection self & dictionaries...
        return filtered.filter({
            (item: K, value: V) -> Bool in
            dictionaries.all { $0.has(item) && $0[item] == value }
        })

    }

    /**
     *  Checks if the specified key exists in the dictionary
     *  @param key Key to check
     *  @return true if the key exists
     */
    func has (key: KeyType) -> Bool {
        return indexForKey(key) != nil
    }
    
    /**
     *  Creates a Dictionary with the same keys as self and values generated by running
     *  each (key, value) of self through the mapFunction
     *  @param mapFunction
     *  @return Mapped dictionary
     */
    func mapValues <V> (mapFunction map: (KeyType, ValueType) -> (V)) -> Dictionary<KeyType, V> {

        var mapped = Dictionary<KeyType, V>()

        self.each({
            mapped[$0] = map($0, $1)
        })

        return mapped

    }
    
    /**
     *  Creates a Dictionary with keys and values generated by running
     *  each (key, value) of self through the mapFunction
     *  @param mapFunction
     *  @return Mapped dictionary
     */
    func map <K, V> (mapFunction map: (KeyType, ValueType) -> (K, V)) -> Dictionary<K, V> {

        var mapped = Dictionary<K, V>()

        self.each({
            let (_key, _value) = map($0, $1)
            mapped[_key] = _value
        })

        return mapped
        
    }

    /**
     *  Loops trough each (key, value) pair in self
     *  @param eachFunction
     */
    func each (eachFunction each: (KeyType, ValueType) -> ()) {

        for (key, value) in self {
            each(key, value)
        }

    }
    
    /**
     *  Constructs a dictionary containing every (key, value) pair from self
     *  for which testFunction evaluates to true.
     *  @param testFunction
     *  @return Filtered dictionary
     */
    func filter (testFunction test: (KeyType, ValueType) -> Bool) -> Dictionary<KeyType, ValueType> {
        
        var result = Dictionary<KeyType, ValueType>()
        
        for (key, value) in self {
            if test(key, value) {
                result[key] = value
            }
        }
        
        return result
        
    }
    
    /**
     *  Returns true if self contains no keys
     *  @return True if self is empty
     */
    func isEmpty () -> Bool {
        return Array(self.keys).isEmpty
    }
    
    /**
    *  Returns a new dictionary containing the contents of self and 
    *  the contents of all the dictionaries passed as parameters
    *  @param dictionaries Dictionaries to merge with self
    *  @return Merge result
    */
    func merge (dictionaries: Dictionary<KeyType, ValueType>...) -> Dictionary<KeyType, ValueType> {

        var result = Dictionary<KeyType, ValueType>()
        let allDictionaries = [self] + dictionaries

        for dictionary in allDictionaries {
            for (key, value) in dictionary {
                result[key] = value
            }
        }
        
        return result

    }

    /**
    *  Creates a dictionary composed of keys generated from the results of running each element of self through groupingFunction. The corresponding value of each key is an array of the elements responsible for generating the key.
    *  @param groupingFunction
    *  @return Grouped dictionary
    */
    func groupBy <T> (groupingFunction group: (KeyType, ValueType) -> T) -> Dictionary<T, Array<ValueType>> {
        
        var result = Dictionary<T, ValueType[]>()
        
        for (key, value) in self {
            
            let groupKey = group(key, value)
            
            // If element has already been added to dictionary, append to it. If not, create one.
            if let elem = result[groupKey] {
                result[groupKey] = elem + [value]
            } else {
                result[groupKey] = [value]
            }
        }
        
        return result
    }
    
    /**
    *  Similar to groupBy, but instead of returning a list of values, returns the number of values for each group
    *  @param groupingFunction
    *  @return Grouped dictionary
    */
    func countBy <T> (groupingFunction group: (KeyType, ValueType) -> (T)) -> Dictionary<T, Int> {
        
        var result = Dictionary<T, Int>()
        
        for (key, value) in self {
            
            let groupKey = group(key, value)
            
            // If element has already been added to dictionary, append to it. If not, create one.
            if let elem = result[groupKey] {
                result[groupKey] = elem + 1
            } else {
                result[groupKey] = 1
            }
        }
        
        return result
    }
    
    /**
    *  Checks if test returns true for all the elements in self
    *  @param test Function to call for each element
    *  @return True if call returns true for all the elements in self
    */
    func all (test: (KeyType, ValueType) -> (Bool)) -> Bool {
        
        for (key, value) in self {
            if !test(key, value) {
                return false
            }
        }
        
        return true
        
    }
    
    /**
    *  Checks if test returns true for any element of self
    *  @param test Function to call for each element
    *  @return True if call returns true for any element of self
    */
    func any (test: (KeyType, ValueType) -> (Bool)) -> Bool {
        
        for (key, value) in self {
            if test(key, value) {
                return true
            }
        }
        
        return false
        
    }

    /**
    *  Same as Array.reduce
    */
    func reduce <U> (initial: U, combine: (U, Element) -> U) -> U {
        return Swift.reduce(self, initial, combine)
    }

    /**
     *  Return a copy of self, filtered to only have values for the whitelisted keys
     */
    func pick (keys: KeyType[]) -> Dictionary {
        return filter { (key: KeyType, _) -> Bool in
            return keys.contains(key)
        }
    }

    func pick (keys: KeyType...) -> Dictionary {
        return pick(reinterpretCast(keys) as KeyType[])
    }
    
    /**
    *  Removes a (key, value) pair from self and returns it as tuple
    *  @return (key, value)
    */
    mutating func shift () -> (KeyType, ValueType) {
        let key: KeyType! = Array(keys).first()
        let value: ValueType! = removeValueForKey(key)

        return (key, value)
    }
}

/**
*  Shorthand for the difference
*/

@infix func - <K, V: Equatable> (first: Dictionary<K, V>, second: Dictionary<K, V>) -> Dictionary<K, V> {
    return first.difference(second)
}

/**
*  Shorthand for the intersection
*/
@infix func & <K, V: Equatable> (first: Dictionary<K, V>, second: Dictionary<K, V>) -> Dictionary<K, V> {
    return first.intersection(second)
}

/**
*  Shorthand for the union
*/
@infix func | <K, V: Equatable> (first: Dictionary<K, V>, second: Dictionary<K, V>) -> Dictionary<K, V> {
    return first.union(second)
}
